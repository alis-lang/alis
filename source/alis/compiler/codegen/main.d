

module alis.compiler.codegen.main;
import alis.compiler.common;
import alis.common;
import alis.compiler.rst;
import std.stdio;
import std.file;

import std.array;
import std.conv;
import std.format;

class BytecodeGenerator {
	private string[][] bytecodeInstructions;
	private int labelCounter = 0;
	private int stackOffset = 0;

	string[][] generateBytecode(RStatement statement) {
		bytecodeInstructions.length = 0;
		labelCounter = 0;
		stackOffset = 0;

		generateStatementBytecode(statement);
		return bytecodeInstructions;
	}

	private void addInstruction(string instruction, string[] params = []) {
		bytecodeInstructions ~= [instruction] ~ params;
	}

	private string generateLabel(string prefix = "label") {
		return format!"%s_%d"(prefix, labelCounter++);
	}

	private void generateStatementBytecode(RStatement statement) {
		writeln("Statement type: ", typeid(statement).toString);
		
		if (auto block = cast(RBlock)statement) {
			generateBlockBytecode(block);
		} else if (auto returnStmt = cast(RReturn)statement) {
			generateReturnBytecode(returnStmt);
		} else if (auto ifStmt = cast(RIf)statement) {
			generateIfBytecode(ifStmt);
		} else if (auto forStmt = cast(RFor)statement) {
			generateForBytecode(forStmt);
		} else if (auto whileStmt = cast(RWhile)statement) {
			generateWhileBytecode(whileStmt);
		} else if (auto doWhileStmt = cast(RDoWhile)statement) {
			generateDoWhileBytecode(doWhileStmt);
		} else if (auto switchStmt = cast(RSwitch)statement) {
			generateSwitchBytecode(switchStmt);
		} else if (auto expr = cast(RExpr)statement) {
			generateExpressionBytecode(expr);
		} else {
			throw new Exception("Unsupported statement type: " ~ typeid(statement).toString);
		}
	}

	private void generateBlockBytecode(RBlock block) {
		writeln("Mock: generateBlockBytecode called: ") ;
	}

	private void generateReturnBytecode(RReturn returnStmt) {
		writeln("Mock: generateReturnBytecode called: ");
	}

	private void generateIfBytecode(RIf ifStmt) {
		writeln("Mock: generateIfBytecode called: ");
	}

	private void generateForBytecode(RFor forStmt) {
		writeln("Mock: generateForBytecode called: ");
	}

	private void generateWhileBytecode(RWhile whileStmt) {
		writeln("Mock: generateWhileBytecode called: ");
	}

	private void generateDoWhileBytecode(RDoWhile doWhileStmt) {
		writeln("Mock: generateDoWhileBytecode called: ");
	}

	private void generateSwitchBytecode(RSwitch switchStmt) {
		writeln("Mock: generateSwitchBytecode called: ");
	}

	private void generateExpressionBytecode(RExpr expr) {
		writeln("Mock: generateExpressionBytecode called: ");
	}

	private void generateLiteralBytecode(RLiteralExpr literalExpr) {
		addInstruction("psh", [convertLiteralToType(literalExpr), convertLiteralToValue(literalExpr)]);
	}

	// Utility methods to convert literals
	private string convertLiteralToType(RLiteralExpr literalExpr) {
		string type = literalExpr.type.toString;
		switch (type) {
			case "int": return "I4";
			case "float": return "F4";
			default: throw new Exception("Unsupported literal type: " ~ type);
		}
	}

	private string convertLiteralToValue(RLiteralExpr literalExpr) {
		string type = literalExpr.type.toString;
		return to!string(literalExpr.value.asBytes);

		switch (type) {
			case "int": 
				return to!string(literalExpr.value.asBytes);
			case "float":
				return to!string(literalExpr.value.asBytes);
			default: 
				throw new Exception("Unsupported literal type: " ~ type);
		}
	}



}



void printBytecode(string[][] bytecodeInstructions) {
	writeln("Generated Bytecode:");
	writeln("------------------");
	foreach (size_t lineNum, instruction; bytecodeInstructions) {
		if (instruction.length == 0) continue;

		string inst = instruction[0];
		string[] params = instruction[1..$];

		if (params.length > 0) {
			writefln("%04d: %s %s", lineNum, inst, params.join(" "));
		} else {
			writefln("%04d: %s", lineNum, inst);
		}
	}
	writeln("------------------");
	writefln("Total Instructions: %d", bytecodeInstructions.length);
}

void printBytecodeToFile(string filename, string[][] bytecodeInstructions) {
	string output;
	foreach (instruction; bytecodeInstructions) {
		if (instruction.length == 0) continue;

		string inst = instruction[0];
		string[] params = instruction[1..$];

		if (params.length > 0) {
			output ~= format!"%s %s\n"(inst, params.join(" "));
		} else {
			output ~= format!"%s\n"(inst);
		}
	}
	output ~= "\n";
	std.file.write(filename, output);

}

private ADataType* getTypeFromString(string typeStr) {
	alias Type = ADataType.Type;
    switch (typeStr) {
        case "int8":
            return new ADataType(false, Type.IntX, 8);
        case "int16":
            return new ADataType(false, Type.IntX, 16);
        case "int32":
            return new ADataType(false, Type.IntX, 32);
        case "int64":
            return new ADataType(false, Type.IntX, 64);
        case "float32":
            return new ADataType(false, Type.FloatX, 32);
        case "float64":
            return new ADataType(false, Type.FloatX, 64);
        default:
            throw new Exception("Unknown type: " ~ typeStr);
    }
}

// Tesing conversion of literals to bytes and then back to values 
unittest{
	string testFolder = "tests/codegen/";
	auto generator = new BytecodeGenerator;

  	// Integer literal
    auto intLiteral = new RLiteralExpr;
    intLiteral.type = getTypeFromString("int32");
    intLiteral.value = asBytes!int(1);

    // Float literal
    auto floatLiteral = new RLiteralExpr;
    floatLiteral.type = getTypeFromString("float32");
    floatLiteral.value = asBytes!float(1.0f);
	writeln(floatLiteral.value);

    // Double literal
    auto doubleLiteral = new RLiteralExpr;
    doubleLiteral.type = getTypeFromString("float64");
    doubleLiteral.value = asBytes!double(3.14159);
	writeln(doubleLiteral.value);

    // Short literal
    auto shortLiteral = new RLiteralExpr;
    shortLiteral.type = getTypeFromString("int16");
    shortLiteral.value = asBytes!short(42);

    // Long literal
    auto longLiteral = new RLiteralExpr;
    longLiteral.type = getTypeFromString("int64");
    longLiteral.value = asBytes!long(123456789);

    // Print converted values
	assert(as!int(intLiteral.value) ==  1);
	assert(as!float(floatLiteral.value) ==  1.0f);
	assert(as!double(doubleLiteral.value) ==  3.14159);
	assert(as!short(shortLiteral.value) ==  42);
	assert(as!long(longLiteral.value) ==  123456789);
	

	bool exceptionThrown = false;
	try {
		auto invalidLiteral = new RLiteralExpr;
		invalidLiteral.type = getTypeFromString("string");
	} catch (Exception e) {
		exceptionThrown = true;
	}
	assert(exceptionThrown);

	RReturn intReturnStmt = new RReturn;
	intReturnStmt.val = intLiteral;

	RReturn floatReturnStmt = new RReturn;
	floatReturnStmt.val = floatLiteral;

	
	auto intBytecode = generator.generateBytecode(intReturnStmt);
	printBytecodeToFile(testFolder ~ "generated_int_code.txt", intBytecode);

	auto floatBytecode = generator.generateBytecode(floatReturnStmt);
	printBytecodeToFile(testFolder ~ "generated_float_code.txt", floatBytecode);

	RBlock block = new RBlock;
	block.statements ~= intReturnStmt;
	block.statements ~= floatReturnStmt;

	RIf ifStmt = new RIf;
	ifStmt.condition = intLiteral;
	ifStmt.onTrue = block;

	RWhile whileStmt = new RWhile;
	whileStmt.condition = floatLiteral;
	whileStmt.body = block;

	RFor forStmt = new RFor;
	forStmt.countIdent = "i"; // TODO check why these are strings
	forStmt.valIdent = "j"; // TODO check why these are strings
	forStmt.body = block;

	RSwitch switchStmt = new RSwitch;
	switchStmt.val = intLiteral;


	block.statements ~= ifStmt;
	block.statements ~= whileStmt;
	block.statements ~= forStmt;
	block.statements ~= switchStmt;

	auto complexBytecode = generator.generateBytecode(block);
	printBytecodeToFile(testFolder ~  "complex_code.txt", complexBytecode);

}


version (codegen) {
	void main() {
		writeln("Testing Bytecode Generator...");
	}
}


